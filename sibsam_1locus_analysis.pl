#!/usr/bin/perl -w
use strict;
use cmdline_args;

if (!$ARGV[0] || $ARGV[0] eq "help"){
    print <<EOF;

This script analyzes output from sibsam_1locus.pl

It requires the following arguments:

-f [file name stem]

There must be a window file with the above stem followed by "_windows.txt"
There must be one or more simulation files from sibsam_null.pl with the file stem followed by "_1locsims*" (where * is any characters)
There must be a primary peak file generated by sibsam_null_analysis.pl with the file stem followed by "_primpeaks_pvalues.txt"
There must be a secondary peak file generated by sibsam_realdata.pl with the file stem followed by "_secpeaks.txt"
Output file will have this file stem appended by "_primpeaks_fullresults.txt" and "_secpeak_pvalues.txt"

EOF
exit 1;
}

my $FileStem = "";
my %args;
$args{'-f'} = [ \$FileStem, 1];

cmdline_args::get_options(\%args, \@ARGV);

my $SimFile = $FileStem . '_1locsims';
my $WinFile = $FileStem . '_windows.txt';
my $PrimPeakFile = $FileStem . '_primpeaks_pvalues.txt';
my $SecPeakFile = $FileStem . '_secpeaks.txt';
my $OutputPrefix = $FileStem;

my $tolerance = 0.025; #height of sim peaks must be within this range of real peak height to accept
my $SmoothEachSide = 4;  #include this many windows on each side of the focal window in a weighted moving average (e.g. if = 4, weights are 1,2,3,4,5,4,3,2,1)
my $PrimPThresh = 0.05;  #only analyze primary peaks with p values below this

#Get cM and depth information from window files
my $CMsX = 0;
my $CMsA = 0;
my $depth = 0;
my @line = ();
my @DepthsXHigh = ();
my @DepthsAHigh = ();
my @DepthsXLow = ();
my @DepthsALow = ();
my @CMStopsX = ();
my @CMStopsA = ();
my @AutoCMBreaks = ();
my @WinChrs = ();
my @AncDiffs = ();

open W, "<$WinFile" or die;
scalar (<W>);
while (<W>){
  chomp;
  last if m/^$/;
  @line = split;
  if ($line[0] =~ m/X/){
    push @CMStopsX, $line[3];
    $depth = int($line[4]);
    push @DepthsXHigh, $depth;
    $depth = int($line[5]);
    push @DepthsXLow, $depth;
  }
  else{
    push @CMStopsA, $line[3];
    $depth = int($line[4]);
    push @DepthsAHigh, $depth;
    $depth = int($line[5]);
    push @DepthsALow, $depth;
  }
  push @WinChrs, $line[0];
  push @AncDiffs, $line[-1];
  $WinChrs[-1] =~ s/L//;
  $WinChrs[-1] =~ s/R//;
}
close W;
$CMsX = $CMStopsX[-1];

my $TotalWindows = @CMStopsA + @CMStopsX;
my $AWindows = @CMStopsA;
my $XWindows = @CMStopsX;


#Get real peak data
my $i = 0;
my @PrimPeakIDs = ();
my @PrimPeakWindows = ();
my @PrimPeakHeights = ();
my @PrimPeakPValues = ();
open P, "<$PrimPeakFile" or die;
scalar <P>;
while (<P>){
  chomp;
  last if m/^$/;
  @line = split;
  push @PrimPeakIDs, $line[0];
  push @PrimPeakWindows, $line[1];
  push @PrimPeakHeights, $line[2];
  push @PrimPeakPValues, $line[3];
}
close P;
$i = @PrimPeakIDs;
print "Found data for $i primary peaks\n";

my @SecPeakPrimIDs = ();
my @SecPeakLeftRights = ();
my @SecPeakWindows = ();
my @SecPeakHeights = ();
my @SecValleyWindows = ();
my @SecValleyHeights = ();
open C, "<$SecPeakFile" or die;
scalar (<C>);
while (<C>){
  chomp;
  last if m/^$/;
  @line = split;
  push @SecPeakPrimIDs, $line[0];
  push @SecPeakLeftRights, $line[1];
  push @SecPeakWindows, $line[2];
  push @SecPeakHeights, $line[3];
  push @SecValleyWindows, $line[4];
  push @SecValleyHeights, $line[5];
}
close C;
$i = @SecPeakPrimIDs;
print "Found data for $i secondary peaks\n";

#get simulation results
my $j = 0;
my @SimPropVars = ();
my @SimPeakHeightAoA = ();
my @SimPeakWindowAoA = ();
my @SimSecDevAoA = ();
my @SimPeakHeights = ();
my @SimPeakWindows = ();
my @SimSecDevs = ();
my @AllFiles = ();
my @SimPeakFiles = ();
opendir DIR, "." or die "couldn't open directory\n";
@AllFiles = readdir(DIR);
closedir DIR;
for ($i = 0; $i < @AllFiles; $i++){
  if (($AllFiles[$i] =~ m/$SimFile/) && ($AllFiles[$i] =~ m/txt/)){
    unless ($AllFiles[$i] =~ m/zip/){
      push @SimPeakFiles, $AllFiles[$i];
    }
  }
}
for ($i = 0; $i < @SimPeakFiles; $i++){
  open S, "<$SimPeakFiles[$i]" or die;
  scalar (<S>);
  while (<S>){
    chomp;
    last if m/^$/;
    @line = split;
    push @SimPropVars, $line[0];
    @SimPeakHeights = ();
    @SimPeakWindows = ();
    @SimSecDevs = ();
    for ($j = 1; $j < @line; $j = $j + 3){
      push @SimPeakHeights, $line[$j];
      push @SimPeakWindows, $line[$j+1];
      push @SimSecDevs, $line[$j+2];
    }
    push @SimPeakHeightAoA, [ @SimPeakHeights ];
    push @SimPeakWindowAoA, [ @SimPeakWindows ];
    push @SimSecDevAoA, [ @SimSecDevs ];
  }
  close S;
}
$i = @SimSecDevAoA;
print "Found data for $i simulated replicates\n";
die if ($i == 0);

#Check which primary peaks meet the P value threshold.  Delete other primary peaks and their associated secondary peaks.
my $p = 0;
for ($i = 0; $i < @PrimPeakIDs; $i++){
  if ($PrimPeakPValues[$i] > $PrimPThresh){
    $p = $PrimPeakIDs[$i];
    splice (@PrimPeakIDs, $i, 1);
    splice (@PrimPeakWindows, $i, 1);
    splice (@PrimPeakHeights, $i, 1);
    splice (@PrimPeakPValues, $i, 1);
    for ($j = 0; $j < @SecPeakPrimIDs; $j++){
      if ($SecPeakPrimIDs[$j] == $p){
	splice (@SecPeakPrimIDs, $j, 1);
	splice (@SecPeakLeftRights, $j, 1);
	splice (@SecPeakWindows, $j, 1);
	splice (@SecPeakHeights, $j, 1);
	splice (@SecValleyWindows, $j, 1);
	splice (@SecValleyHeights, $j, 1);
	$j--;
      }
    }
    $i--;
  }
}


$i = @PrimPeakIDs;
print "Analyzing $i significant primary peaks from real and simulated data...\n";
if (@PrimPeakIDs != @{$SimPeakHeightAoA[0]}){
  $j = @{$SimPeakHeightAoA[0]};
  print "$i != $j\n";
  die;
}

#For each primary peak, record propvars, vertdevs, and secdevs of the simulated loci that fall within the peak height tolerance
my @GoodPropVars = ();
my @GoodPeakWindows = ();
my @GoodSecDevs = ();
my @TotalSimsFit = ();
my @PropVar5 = ();
my @PropVar95 = ();
my @SecDev95 = ();
my @PropVar50 = ();
my @AdjustedSecValleyHeights = ();
my @AdjustedSecValleyWindows = ();
my @SecPeakPValues = ();
my @SecPeakDeviations = ();
my @LeftBounds = ();
my @RightBounds = ();
my $k = 0;
my $l = 0;
my $ClusterStart = 0;
my $ClusterStop = 0;
my $SecDev = 0;
my $AdjustedValleyHeight = 0;
my $AdjustedValleyWindow = 0;
my $LowestValleyAwayHeight = 0;
my $LowestValleyAwayWindow = 0;
my $HighThreshRank = 0;
my $LowThreshRank = 0;
my $PValue = 0;
my $half = 0;
my $MedianValue = 0;
for ($i = 0; $i < @PrimPeakIDs; $i++){
  @GoodPropVars = ();
  @GoodPeakWindows = ();
  @GoodSecDevs = ();

  for ($j = 0; $j < @SimPeakHeightAoA; $j++){
    if ( (abs($PrimPeakHeights[$i] - $SimPeakHeightAoA[$j][$i])) <= $tolerance){
      push @GoodPropVars, $SimPropVars[$j];
      push @GoodPeakWindows, $SimPeakWindowAoA[$j][$i];
      push @GoodSecDevs, $SimSecDevAoA[$j][$i];
    }
  }

  $j = @GoodPropVars;
  push @TotalSimsFit, $j;

#Obtain desired critical values for each primary peak  
  @GoodPropVars = sort {$a <=> $b} @GoodPropVars;
  @GoodPeakWindows = sort {$a <=> $b} @GoodPeakWindows;
  @GoodSecDevs = sort {$a <=> $b} @GoodSecDevs;
  $HighThreshRank = int(@GoodPropVars * 0.95) + 1;
  $LowThreshRank = int(@GoodPropVars * 0.05);
  push @PropVar5, $GoodPropVars[$LowThreshRank];
  push @PropVar95, $GoodPropVars[$HighThreshRank];
  push @LeftBounds, $GoodPeakWindows[$LowThreshRank]; 
  push @RightBounds, $GoodPeakWindows[$HighThreshRank];
  push @SecDev95, $GoodSecDevs[$HighThreshRank];
  if ((@GoodPropVars % 2) == 0){
    $half = @GoodPropVars / 2;
    $MedianValue = ($GoodPropVars[$half] + $GoodPropVars[$half-1]) / 2;
    push @PropVar50, $MedianValue;
  }
  else{
    $half = int(@GoodPropVars / 2);
    $MedianValue = $GoodPropVars[$half];
    push @PropVar50, $MedianValue;
  }
  print "Evaluated thresholds for primary peak $PrimPeakIDs[$i]\n";
  
#Evaluate P Value for each secondary peak associated with this primary peak

#if there's just 1 secondary peak on a given side of the primary peak,
#calculate sec dev from local valley and peak heights, then calculate P value based on simulation sec dev's.  
  for ($j = 0; $j < @SecPeakPrimIDs; $j++){
    next if ($SecPeakPrimIDs[$j] < $PrimPeakIDs[$i]);
    last if ($SecPeakPrimIDs[$j] > $PrimPeakIDs[$i]);
    if (($j == (@SecPeakPrimIDs - 1)) || ($SecPeakPrimIDs[$j+1] != $PrimPeakIDs[$i]) || ($SecPeakLeftRights[$j] ne $SecPeakLeftRights[$j+1])){    
      $SecDev = $SecPeakHeights[$j] - $SecValleyHeights[$j];
      if(@GoodSecDevs > 19){
	for ($k = 0; $k < @GoodSecDevs; $k++){
	  if ($GoodSecDevs[$k] > $SecDev){
	    $PValue = (@GoodSecDevs - $k) / @GoodSecDevs;
	    last;
	  }
	}
      }
      else{
	$PValue = 999;
      }
      push @AdjustedSecValleyHeights, $SecValleyHeights[$j];
      push @AdjustedSecValleyWindows, $SecValleyWindows[$j];
      push @SecPeakDeviations, $SecDev;
      push @SecPeakPValues, $PValue;
      next;
    }
#If 2 or more sec peaks on the same side, evaluate sec dev and P value after redefining valley for each sec peak...
#Taller peaks can have adjusted valleys lower than their local valleys by borrowing the lowest valley toward the primary peak,
#and shorter peaks may get valleys raised based on taller secondary peaks farther away from the primary peak.
    else{
      $ClusterStart = $j;
      while (($SecPeakPrimIDs[$j+1] == $SecPeakPrimIDs[$j]) && ($SecPeakLeftRights[$j] eq $SecPeakLeftRights[$j+1])){
	$j++;
	last if ($j == (@SecPeakPrimIDs - 1));
      }
      $ClusterStop = $j;
      for ($k = $ClusterStart; $k <= $ClusterStop; $k++){
	$AdjustedValleyHeight = $SecValleyHeights[$k];
	$AdjustedValleyWindow = $SecValleyWindows[$k];
	
#For a secondary peak LEFT of its primary peak,
#move toward the primary peak and check if we can borrow a lower valley from a shorter peak.
#Stop looking if we get to a taller secondary peak.	
	if ($SecPeakLeftRights[$k] eq 'L'){
	  for ($l = $k + 1; $l <= $ClusterStop; $l++){
	    last if ($SecPeakHeights[$l] > $SecPeakHeights[$k]);
	    if ($SecValleyHeights[$l] < $AdjustedValleyHeight){
	      $AdjustedValleyHeight = $SecValleyHeights[$l];
	      $AdjustedValleyWindow = $SecValleyWindows[$l];
	    }
	  }
#Then check moving away from the peak to see if a taller peak exists (which could usurp this peak's valley)...
#If so, compare the lowest valley between the focal secondary peak and the taller/farther one versus
#the adjusted valley between the focal secondary peak and the primary peak.  Retain the taller valley.
	  $LowestValleyAwayHeight = 1;
	  for ($l = $k - 1; $l >= $ClusterStart; $l--){
	    if ($SecValleyHeights[$l] < $LowestValleyAwayHeight){
	      $LowestValleyAwayHeight = $SecValleyHeights[$l];
	      $LowestValleyAwayWindow = $SecValleyWindows[$l];
	    }
	    if ($SecPeakHeights[$l] > $SecPeakHeights[$k]){
	      if ($LowestValleyAwayHeight > $AdjustedValleyHeight){
		$AdjustedValleyHeight = $LowestValleyAwayHeight;
		$AdjustedValleyWindow = $LowestValleyAwayWindow;
	      }
	      last;
	    }
	  }
	}
	
#For a secondary peak RIGHT of its primary peak,
#move toward the primary peak and check if we can borrow a lower valley from a shorter peak.
#Stop looking if we get to a taller secondary peak.	
	else{
	  for ($l = $k - 1; $l >= $ClusterStart; $l--){
	    last if ($SecPeakHeights[$l] > $SecPeakHeights[$k]);
	    if ($SecValleyHeights[$l] < $AdjustedValleyHeight){
	      $AdjustedValleyHeight = $SecValleyHeights[$l];
	      $AdjustedValleyWindow = $SecValleyWindows[$l];
	    }
	  }
#Then check moving away from the peak to see if a taller peak exists (which could usurp this peak's valley)...
#If so, compare the lowest valley between the focal secondary peak and the taller/farther one versus
#the adjusted valley between the focal secondary peak and the primary peak.  Retain the taller valley.
	  $LowestValleyAwayHeight = 1;
	  for ($l = $k + 1; $l <= $ClusterStop; $l++){
	    if ($SecValleyHeights[$l] < $LowestValleyAwayHeight){
	      $LowestValleyAwayHeight = $SecValleyHeights[$l];
	      $LowestValleyAwayWindow = $SecValleyWindows[$l];
	    }
	    if ($SecPeakHeights[$l] > $SecPeakHeights[$k]){
	      if ($LowestValleyAwayHeight > $AdjustedValleyHeight){
		$AdjustedValleyHeight = $LowestValleyAwayHeight;
		$AdjustedValleyWindow = $LowestValleyAwayWindow;
	      }
	      last;
	    }
	  }
	}
	$SecDev = $SecPeakHeights[$k] - $AdjustedValleyHeight;
	if(@GoodSecDevs > 19){
	  for ($l = 0; $l < @GoodSecDevs; $l++){
	    if ($GoodSecDevs[$l] > $SecDev){
	      $PValue = (@GoodSecDevs - $l) / @GoodSecDevs;
	      last;
	    }
	    if ($l == (@GoodSecDevs - 1)){
	      $PValue = 0;
	    }
	  }
	}
	else{
	  $PValue = 999;
	}
	push @AdjustedSecValleyHeights, $AdjustedValleyHeight;
	push @AdjustedSecValleyWindows, $AdjustedValleyWindow;
	push @SecPeakDeviations, $SecDev;
	push @SecPeakPValues, $PValue;
      }
    }
  }
  print "Evaluated secondary peaks for primary peak $PrimPeakIDs[$i]\n";
}
if (@SecPeakDeviations != @SecPeakPrimIDs){
  $i = @SecPeakDeviations;
  $j = @SecPeakPrimIDs;
  print "Found $i deviations for $j secondary peaks\n";
  die;
}

#zip up the sim files to get them out of the way
my $cmd = 'zip ' . $SimFile . '.zip';
for ($i = 0; $i < @SimPeakFiles; $i++){
  $cmd = $cmd . ' ' . $SimPeakFiles[$i];
}
system($cmd);
for ($i = 0; $i < @SimPeakFiles; $i++){
  $cmd = 'rm ' . $SimPeakFiles[$i];
  system($cmd);
}

#Output
my $file = $OutputPrefix . '_primpeaks_fullresults.txt';
open O, ">$file";
print O "PeakID\tPeakWindow\tPeakHeight\tPeakPValue\tMatchingSim\tPropVar50th\tPropVar5th\tPropVar95th\tLeftWinBound\tRightWinBound\tSecDev95th\n";
for ($i = 0; $i < @PrimPeakIDs; $i++){
  print O "$PrimPeakIDs[$i]\t$PrimPeakWindows[$i]\t$PrimPeakHeights[$i]\t$PrimPeakPValues[$i]\t$TotalSimsFit[$i]\t$PropVar50[$i]\t$PropVar5[$i]\t$PropVar95[$i]\t$LeftBounds[$i]\t$RightBounds[$i]\t$SecDev95[$i]\n";
}
close O;

$file = $OutputPrefix . '_secpeaks_pvalues.txt';
open U, ">$file";
print U "PrimPeakID\tPrimPeakSide\tSecPeakWindow\tSecPeakHeight\tSecLocalValleyWindowt\tSecLocalValleyHeight\tSecAdjValleyWindow\tSecAdjValleyHeight\tSecPeakDeviation\tSecPeakPValue\n";
for ($i = 0; $i < @SecPeakPrimIDs; $i++){
  print U "$SecPeakPrimIDs[$i]\t$SecPeakLeftRights[$i]\t$SecPeakWindows[$i]\t$SecPeakHeights[$i]\t$SecValleyWindows[$i]\t$SecValleyHeights[$i]\t$AdjustedSecValleyWindows[$i]\t$AdjustedSecValleyHeights[$i]\t$SecPeakDeviations[$i]\t$SecPeakPValues[$i]\n";
}
close U;
