#!/usr/bin/perl -w
use strict;
use cmdline_args;

if (!$ARGV[0] || $ARGV[0] eq "help"){
    print <<EOF;

This script collects output from sibsam analysis scripts and returns information about each significant QTL peak

It requires the following arguments:

-f [file name stem]

There must be a window file with the above stem followed by "_windows.txt"
There must be a primary peak file generated by sibsam_1locus_analysis.pl with the file stem followed by "_primpeaks_fullresults.txt"
There may be a secondary peak file generated by sibsam_1locus_analysis.pl with the file stem followed by "_secpeaks_pvalues.txt"
There may be one or more cluster results file generated by sibsam_cluster_analysis.pl with the file stem followed by "_clusterXresults.txt", where X denotes cluster number.
Output file will have this file stem appended by "_finalresults.txt"

EOF
exit 1;
}

my $FileStem = "";
my %args;
$args{'-f'} = [ \$FileStem, 1];

cmdline_args::get_options(\%args, \@ARGV);

my $WinFile = $FileStem . '_windows.txt';
my $PrimPeakFile = $FileStem . '_primpeaks_fullresults.txt';
my $SecPeakFile = $FileStem . '_secpeaks_pvalues.txt';
my $ClusterFileStart = $FileStem . '_cluster';
my $ClusterFileEnd = 'results.txt';
my $OutputFile = $FileStem . '_finalresults.txt';

my $SecPeakPThresh = 0.05;

#Get information from window files
my @line = ();
my @WinChrs = ();
my @WinStarts = ();
my @WinStops = ();
open W, "<$WinFile" or die;
scalar (<W>);
while (<W>){
  chomp;
  last if m/^$/;
  @line = split;
  push @WinChrs, $line[0];
  push @WinStarts, $line[1];
  push @WinStops, $line[2];
}
close W;

#Get real peak data
my $i = 0;
my @PrimPeakAoA = ();
open P, "<$PrimPeakFile" or die;
scalar <P>;
while (<P>){
  chomp;
  last if m/^$/;
  @line = split;
  push @PrimPeakAoA, [ @line ];
}
close P;
$i = @PrimPeakAoA;
print "Found data for $i primary peaks\n";

my @SecPeakAoA = ();
open S, "<$SecPeakFile";
scalar (<S>);
while (<S>){
  chomp;
  last if m/^$/;
  @line = split;
  if ($line[-1] < $SecPeakPThresh){
    push @SecPeakAoA, [ @line ];
  }
}
close S;
$i = @SecPeakAoA;
print "Found data for $i secondary peaks\n";

#Summarize quantities of interest for each peak
my @PeakWins = ();
my @PeakHeights = ();
my @PeakTypes = ();
my @PValues = ();
my @MatchSims = ();
my @PropVar50s = ();
my @PropVar5s = ();
my @PropVar95s = ();
my @LeftBoundWins = ();
my @RightBoundWins = ();
my $NextPeak = '';

while ((@PrimPeakAoA > 0) || (@SecPeakAoA > 0)){
  if (@SecPeakAoA == 0){
    $NextPeak = 'primary';
  }
  elsif ((@PrimPeakAoA == 0) || ($PrimPeakAoA[0][1] > $SecPeakAoA[0][2])){
    $NextPeak = 'secondary';
  }
  else{
    $NextPeak = 'primary';
  }
  if ($NextPeak eq 'primary'){
    push @PeakWins, $PrimPeakAoA[0][1];
    push @PeakHeights, $PrimPeakAoA[0][2];
    push @PeakTypes, $NextPeak;
    push @PValues, $PrimPeakAoA[0][3];
    push @MatchSims, $PrimPeakAoA[0][4];
    push @PropVar50s, $PrimPeakAoA[0][5];
    push @PropVar5s, $PrimPeakAoA[0][6];
    push @PropVar95s, $PrimPeakAoA[0][7];
    push @LeftBoundWins, $PrimPeakAoA[0][8];
    push @RightBoundWins, $PrimPeakAoA[0][9];
    shift @PrimPeakAoA;
  }
  else{
    push @PeakWins, $SecPeakAoA[0][2];
    push @PeakHeights, $SecPeakAoA[0][3];
    push @PeakTypes, $NextPeak;
    push @PValues, $SecPeakAoA[0][9];
    push @MatchSims, 0;
    push @PropVar50s, 0;
    push @PropVar5s, 0;
    push @PropVar95s, 0;
    push @LeftBoundWins, 0;
    push @RightBoundWins, 0;
    shift @SecPeakAoA;
  }
}
    
#get peak data from each cluster file. 
my @ClusterFiles = ();
opendir DIR, "." or die "couldn't open directory\n";
my @AllFiles = readdir(DIR);
closedir DIR;
for ($i = 0; $i < @AllFiles; $i++){
  if (($AllFiles[$i] =~ m/$ClusterFileStart/) && ($AllFiles[$i] =~ m/$ClusterFileEnd/)){
    push @ClusterFiles, $AllFiles[$i];
  }
}
my @ClusterPeakAoA = ();
for ($i = 0; $i < @ClusterFiles; $i++){
  open C, "<$ClusterFiles[$i]" or die;
  scalar (<C>);
  while (<C>){
    chomp;
    last if m/^$/;
    @line = split;
    push @ClusterPeakAoA, [ @line ];
  }
  close C;
}
$i = @ClusterPeakAoA;
my $j = @ClusterFiles;
print "$i peaks were in $j clusters\n";

# replace peak types, matchsims, propvars, and genomic CIs for cluster peaks
for ($i = 0; $i < @ClusterPeakAoA; $i++){
  for ($j = 0; $j < @PeakWins; $j++){
    if ($ClusterPeakAoA[$i][0] == $PeakWins[$j]){
      $MatchSims[$j] = $ClusterPeakAoA[$i][2];
      $PropVar50s[$j] = $ClusterPeakAoA[$i][3];
      $PropVar5s[$j] = $ClusterPeakAoA[$i][4];
      $PropVar95s[$j] = $ClusterPeakAoA[$i][5];
      $LeftBoundWins[$j] = $ClusterPeakAoA[$i][6];
      $RightBoundWins[$j] = $ClusterPeakAoA[$i][7];
      $PeakTypes[$j] = $PeakTypes[$j] . '_cluster';
      last;
    }
  }
}

#replace window numbers with window coordinates
my $win = 0;
my $pos = 0;
my $chr = '';
my @chrs = ();
my @PeakStartPos = ();
my @PeakStopPos = ();
my @LeftBoundPos = ();
my @RightBoundPos = ();
for ($i = 0; $i < @PeakWins; $i++){
  $win = $PeakWins[$i];
  $chr = $WinChrs[$win];
  push @chrs, $chr;
  $pos = $WinStarts[$win];
  push @PeakStartPos, $pos;
  $pos = $WinStops[$win];
  push @PeakStopPos, $pos;
  $win = $LeftBoundWins[$i];
  $pos = $WinStarts[$win];
  push @LeftBoundPos, $pos;
  $win = $RightBoundWins[$i];
  $pos = $WinStops[$win];
  push @RightBoundPos, $pos;
}
for ($i = 1; $i < @LeftBoundWins; $i++){
  if ($LeftBoundWins[$i] == $RightBoundWins[$i-1]){
    $RightBoundPos[$i-1] = int(($LeftBoundPos[$i] + $RightBoundPos[$i-1])/2);
    $LeftBoundPos[$i] = $RightBoundPos[$i-1] + 1;
  }
}

#Output
open O, ">$OutputFile";
print O "Chr\tPeakWinStart\tPeakWinStop\tPeakHeight\tPeakType\tPValue\tMatchingSims\tPropVarMedian\tPropVar5th\tPropVar95th\tLeftBoundPos\tRightBoundPos\n";
for ($i = 0; $i < @chrs; $i++){
  print O "$chrs[$i]\t$PeakStartPos[$i]\t$PeakStopPos[$i]\t$PeakHeights[$i]\t$PeakTypes[$i]\t$PValues[$i]\t$MatchSims[$i]\t$PropVar50s[$i]\t$PropVar5s[$i]\t$PropVar95s[$i]\t$LeftBoundPos[$i]\t$RightBoundPos[$i]\n";
}
close O;
